# 전역 변수의 문제점
## 1. 변수의 생명 주기
### 지역 변수의 생명 주기
* 함수 내부에서 선언된 지역변수의 경우, 지역 변수의 생명 주기는 대부분 함수의 생명 주기와 일치
* 하지만, 지역 변수가 함수보다 오래 생존하는 경우도 있음
  * 지역 변수는 함수가 생성한 스코프에 등록이 됨
  => 누군가 참조하고 있다면 소멸하지 않고 생존하게 됨
(클로저 챕터에서 자세히 설명)
* 호이스팅은 스코프 단위로 동작
  * 지역 변수의 호이스팅은 지역 변수의 선언이 지역 스코프의 선두로 끌어 올려진 것처럼 동작

### 전역 변수의 생명 주기
* 전역 코드는 명시적 호출 없이 실행 (코드가 로드되자마자)
* var로 선언한 전역 변수는 전역 객체의 프로퍼티가 됨
  => 전역 변수의 생명 주기가 전역 객체의 생명 주기와 일치
* 전역 객체
  * 코드가 실행되기 이전 단계에 JS엔진에 의해 가장 먼저 생성되는 특수한 객체
  * 브라우저 환경에선 `window` 객체, Node.js 환경에서는 `global` 객체를 의미
  * 환경에 따라 다양한 식별자가 존재했으나, ES11에서 `globalThis`로 통일
  * 표준 빌트인 객체, 호스트 객체, var로 선언한 전역 변수와 전역 함수를 프로퍼티로 가짐

</br>

## 2. 전역 변수의 문제점
* 암묵적 결합
  * 모든 코드가 전역 변수를 참조하고 변경할 수 있음
* 긴 생명 주기
  * 메모리 오랜 기간 소비
  * 전역 변수의 상태를 변경할 수 있는 기회가 많아짐..
* 스코프 체인 상에서 종점에 존재
  * 스코프 체인 상 마지막에 존재해서 검색 속도가 가장 느림
* 네임스페이스 오염
  * 파일이 분리되어있어도 하나의 전역 스코프를 공유하기에 예상치 못한 결과가 발생할 수 있음

*** 되도록 지역 변수를 사용하자***

</br>

## 3 전역 변수의 사용을 억제하는 방법
### 즉시 실행 함수
* 모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행함수의 지역 변수가 됨
* 전역 변수를 생성하지 않으므로 라이브러리 등에 자주 사용되는 방법

### 네임스페이스 객체
* 전역에 네임 스페이스 역할을 할 객체를 생성 후, 전역 변수처럼 쓰고 싶은 변수를 해당 객체의 프로퍼티로 추가하는 방법
* 네임 스페이스 역할을 하는 객체..자체가 전역 변수라서 그렇게 유용한 방법은 아님

### 모듈 패턴
* 관련 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만드는 것 (클래스 모방)
* 전역 변수 억제 기능 + 캡슐화까지 구현 가능
* 캡슐화
  * 프로퍼티와 메서드를 하나로 묶는 것을 말함
  * 특정 프로퍼티나 메서드를 감출 목적으로 사용하는 경우에 `정보 은닉`이라고 함
* JS는 public, private, protected 등 접근 제한자가 없기 때문에.. 정보 은닉을 구현하기 위해 모듈 패턴 사용

```js
var Counter = (function(){
//private 변수는 여기에 쓰고
  
  return {
   // 외부로 공개할 데이터나 메서드는 여기에 씀
  }
}())

```

### ES6 모듈
* ES6 모듈을 사용하면 파일 자체의 독자적인 모듈 스코프를 제공 => 전역 변수 사용 불가
* `script` 태그에 `type='module'` 어트리뷰트를 추가하면, 로드된 js 파일은 모듈로서 동작
  (모듈 파일 확장자는 `mjs` 권장)
```html
<script type="module" src="lib.mjs"></script>
```
* 근데 이거 보다 Webpack 등의 모듈 번들러를 사용하는 것이 일반적이라고 함
(구형 브라우저에서 동작하지 않고, 사용해도 추가로 트랜스파일링이나 번들링이 필요해서..)
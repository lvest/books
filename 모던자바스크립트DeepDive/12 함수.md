# 함수

## 1. 함수란?

- 일련의 과정을 문(statement)으로 구현하고 코드 블록으로 감싸 하나의 실행 단위로 정의한 것
- `매개변수(parameter)` - 함수 내부로 입력을 전달 받는 변수
- `인수(argument)` - 입력
- `반환값(return value)` - 출력
- 함수 정의를 통해 생성, 호출을 통해 실행

</br>

## 2. 함수를 사용하는 이유

- 코드의 재사용
- 유지보수의 편의성
- 코드의 신뢰성
- 코드의 가독성

</br>

## 3. 함수 리터럴

- JS의 함수는 객체 타입의 값

```js
let f = function add(x, y) {
  return x + y;
};
```

- 함수 리터럴 구성 요소

  - 함수 이름
    - 식별자이기 때문에 식별자 네이밍 규칙 준수해야함
    - _함수 몸체 내에서만_ 참조 가능
    - 생략 가능, 이름이 없는 함수를 `익명함수`라 함
  - 매개변수 목록
    - 함수 호출 시 지정한 인수가 매개변수에 차례로 할당
    - 함수 몸체 내에서 변수와 동일하게 취급
  - 함수 몸체
    - 함수가 호출되었을 때 실행될 문들을 하나의 실행 단위로 정의한 코드 블록

- 함수 리터럴로 생성 가능
  => 리터럴은 평가되어 값을 생성함
  => 함수 리터럴도 평가되어 값을 생성하며, 이 값은 객체
- `함수 = 객체`는 다른 언어와 구별되는 JS의 특징
  일반 객체와 차이점 : 일반 객체는 호출 불가, 함수는 호출 가능
  (나중 챕터에서 공부)

</br>

## 4. 함수 정의

### 함수 선언문

- 함수 리터럴과 형태 동일, but 함수 이름 생략 불가
- 표현식이 아닌 문임 => 변수에 할당 불가
- JS엔진이 문맥에 따라 함수 리터럴 혹은 함수 선언문 중 하나로 해석함
  - 기명함수 단독 사용(피연산자가 아닌 경우) => 함수 선언문으로 해석
  - 값으로 평가 되어야 하는 문맥 => 함수 리터럴로 해석
- 과정
  - JS엔진은 함수 선언문을 해석 후, 함수 객체 생성하는데,
  - 함수 이름과 동일한 이름의 식별자를 생성 후, 생성한 함수 객체를 할당한다
    (함수 이름은 함수 몸체 내에서만 참조 가능하기 때문에, 함수 호출하려면 필요함)
    => **함수는 함수 이름으로 호출 X, 함수 객체를 가리키는 식별자로 호출 O**

### 함수 표현식

- JS에서 함수는 일급 객체이므로 생성한 함수 객체를 변수에 할당 가능 => 함수 표현식
- 함수 이름 생략 가능
- **함수는 함수 이름으로 호출 X, 함수 객체를 가리키는 식별자로 호출 O**

```js
let add = function foo(x, y) {
  return x + y;
};

// 함수 객체를 가리키는 식별자로 호출
console.log(add(2, 5)); // 7

// 함수 이름으로 호출
console.log(foo(2, 5)); // ReferenceError: foo is not defined
```

### 함수 생성 시점과 함수 호이스팅

- 함수 선언문은 함수 호이스팅이 되지만, 함수 표현식은 변수 호이스팅이 됨

- 함수 선언문
  - 런타임 이전에 먼저 실행
    => 함수 객체가 생성되고,
    => 같은 이름으로 식별자 만들어지고,
    => 식별자를 해당 객체로 초기화까지
    다 런타임 이전
    => 런타임 중에는 선언문 이전이라도 참조 가능, 호출 가능 (함수 호이스팅)
- 함수 표현식
  - 변수 할당문의 값은 런타임에 평가되므로, 함수 표현식의 함수 리터럴은 할당문이 실행되는 시점에서 평가되어 함수 객체가 됨..
  - 즉 함수 호이스팅이 아닌 변수 호이스팅이 발생

```js
console.dir(add); // f add(x,y)
console.dir(sub); // undefined

console.log(add(2, 5)); // 7;
console.log(sub(2, 5)); // TypeError: sub is not a function
// undefined로 초기화됐으므로 TypeError 발생

function add(x, y) {
  return x + y;
}

var sub = function add(x, y) {
  return x - y;
};
```

### Function 생성자 함수

- JS에서 기본 제공하는 빌트인 함수 Function 이용
- 권장되지 않음
- 클로저를 생성하지 않는 등, 함수 선언문이나 표현식으로 생성한 함수와 다르게 동작

### 화살표 함수(ES6)

- `function` 키워드 대신 화살표 `=>` 이용
- 항상 익명 함수로 정의
- 생성자 함수 사용 X, this 바인딩 방식 다름, prototype 프로퍼티 없음, argument 객체 생성 X
  (나중 챕터에서 공부)

</br>

## 5. 함수 호출

### 매개변수와 인수

- 인수
  - 값으로 평가될 수 있는 표현식이어야 함
  - 함수 호출 시에 지정
- 매개변수
  - 함수 몸체 내부에서 변수와 동일하게 취급
  - 함수 몸체 내부에서만 참조 가능
- 매개변수 > 인수
  - 남은 매개변수는 undefined (에러 안 생김)
- 매개변수 < 인수
  - 남은 인수 무시
  - 하지만 모든 인수는 암묵적으로 arguments 객체의 프로퍼티에 보관됨

```js
function add(x, y) {
  console.log(arguments);
  return x + y;
}

add(2, 5, 10);
```

### 인수 확인

- JS는 적절한 인수가 전달되었는지 확인하지 않으므로, 함수 내부에서 타입이나 인수 개수에 따른 처리를 해주는 것이 필요함
- ES6에서 도입된 기본값 사용하거나 단축 평가 사용, arguments 객체 통해 인수 개수 확인 등.. 아니면 그냥 TS 쓰자

### 매개변수의 최대 개수

- 제한은 없지만 적을 수록 좋음 (최대 3개는 넘지 않는 것을 권장)
- 함수는 되도록 작게, 한 가지 일만 하게 만들자
- 만약 많은 매개변수가 필요하다면, 그냥 객체를 인수로 전달하는 것이 유리
  (이 경우엔, 외부 객체가 변경 되는 부수 효과 발생 할 수도 있기에, 깊은 복사를 통해 새로운 객체를 사용하자)

### 반환문

- 반환문을 만나면 함수 실행 중단, 함수 몸체 빠져나감
  => 반환문 이후의 문은 실행 X
- return 키워드 뒤에 오는 표현식을 평가하여 반환
  => 표현식이 없으면 undefined 반환
- 생략 시, 암묵적으로 undefined 반환
- 함수 몸체 내에서만 사용 가능
  - 전역에서 사용시 Syntex Error 반환
  - Node.js의 경우, 파일 스코프를 갖기 때문에 에러 발생 X

</br>

## 6. 참조에 의한 전달과 외부 상태의 변경

- 원시 타입 인수
  - 값 자체가 복사되어 매개변수에 전달 됨 => 값을 변경해도 원본 훼손 X
- 객체 타입 인수
  - 참조 값이 복사되에 매개변수에 전달 됨 => 원본 훼손 O
  - 깊은 복사를 통해 불변 객체로 만들어 부수효과를 없애자

</br>

## 7. 다양한 함수의 형태

### 즉시 실행 함수

- 함수 정의와 동시에 호출됨
- 단 한번만 호출되며, 다시 호출할 수 없음
- 익명이 일반적이나, 기명함수도 가능
- 먼저 함수 리터럴을 평가해서 함수 객체를 생성할 수 있게 해야함
  (그룹 연산자 `()`로 감싸는게 일반적)

```js
(function () {
  /*블라블라*/
})();

(function () {
  /*블라블라*/
})();

!(function () {
  /*블라블라*/
})();

+(function () {
  /*블라블라*/
})();
```

- 일반 함수처럼 값 반환, 인수 전달 가능

### 재귀 함수

- 함수가 자기 자신을 호출 하는 것
- 반복되는 처리를 위해 사용
- 탈출 조건을 반드시 만들어야 함 => 안 만들면 stack overflow 에러 발생

### 중첩 함수

- `중첩 함수` 혹은 `내부 함수` - 함수 내부에 정의된 함수
- `외부 함수` - 중첩 함수를 포함하는 함수
- 중첩 함수는 외부 함수 내부에서만 호출 가능
- 보통 외부 함수를 돕는 헬퍼 함수의 역할을 함

### 콜백 함수

- `콜백 함수` - 매개변수를 통해 다른 함수의 내부로 전달되는 함수
- `고차 함수` - 함수의 외부에서 콜백함수를 전달받은 함수
  (혹은 반환값으로 함수를 반환하거나)
- 콜백함수는 고차 함수를 돕는 헬퍼함수의 역할
- 고차함수는 콜백함수를 자신의 일부분으로 합성
- 함수 합성
  - 공통 로직은 미리 정의
  - 경우에 따라 변경되는 로직은 추상화해서 함수 외부에서 내부로 전달

### 순수 함수와 비순수 함수

- `순수 함수` - 부수효과가 없는 함수
- `비순수 함수` - 부수효과가 있는 함수
- 순수 함수
  - 외부 상태에 의존하지도 않고, 외부상태를 변경하지도 않음)
  - 동일한 인수 전달 시, 언제나 동일한 값 반환
  - 오직 인수에만 의존해 반환값 생성
  - 외부 상태를 변경하지도 않음
- 비순수 함수
  - 외부 상태에 의존하거나 외부상태를 변경함
- 함수가 외부 상태를 변경하면 추적하기 어렵기 때문에 되도록 순수 함수를 사용하는 것이 좋음

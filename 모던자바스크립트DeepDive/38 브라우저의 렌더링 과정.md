# 브라우저의 렌더링 과정

필요한 리소스(HTML, CSS, 자바스크립트, 이미지, 폰트 등의 정적 파일 또는 서버가 동적으로 생성한 데이터)를 서버에 요청하고 응답 받아 렌더링

</br>

## 1. 요청과 응답

- 필요한 리소스를 서버에 요청하고 응답 받음
  1. 브라우저 주소창에 URL 입력
  2. URL의 호스트 이름이 DNS를 통해 IP로 변환, 해당 IP를 갖는 서버에게 요청 전송
     => 루트 요청(scheme과 host만으로 구성된 URI)시, 암묵적으로 index.html 응답

</br>

## 2. HTTP 1.1과 HTTP 2.0

- HTTP
  - 웹에서 브라우저와 서버가 통신하기 위한 프로토콜(규약)
- HTTP 1.1
  - 커넥션 당 하나의 요청과 응답만 처리
  - 여러 개의 요청 X, 여러 개의 응답 X
  - 리소스의 동시 전송이 불가능 함 => 요청할 리소스 개수에 비례하여 응답시간 증가
- HTTP 2.0
  - 다중 요청, 응답 가능
  - 여러 리소스 동시 전송 가능 => HTTP 1.1에 비해 페이지 로드 속도가 빠름

</br>

## 3. HTML 파싱과 DOM 생성

- HTML문서를 렌더링하기 위해서는 브라우저가 이해할 수 있는 자료구조(객체)로 변환하여 메모리에 저장해야 함
- DOM이란 HTML 문서를 파싱한 결과물

**과정**

1. 브라우저는 서버로부터 요청한 HTML문서를 바이트(2진수) 형태로 응답받음 => 지정된 인코딩 방식을 기준으로 문자열로 변환
   (지정된 인코딩 방식 : meta 태그의 charset 어트리뷰트에 선언하며, 응답 헤더에 담겨 응답됨)

2. 문자열로 변환된 HTML 문서를 읽어들여 문법적 의미를 갖는 최소 단위인 token들로 분해함

3. 각 토큰을 객체로 변환하여 Node 생성. 토큰의 내용에 따라 문서 노드, 요소 노드, 어트리뷰트 노드, 텍스트 노드로 나뉨

4. HTML 요소 간의 부자관계를 반영하여 모든 노드를 트리 자료구조로 변환 => DOM

</br>

## 4. CSS 파싱과 CSSOM 생성

1. 렌더링 엔진이 HTML을 파싱하며 DOM을 만들다가,
2. `link태그`나 `style태그`를 만나면 DOM 생성을 일시 중단하고,
3. CSS 파일을 요청하여 HTML 파싱과 동일한 과정을 거침 => CSSOM
4. CSS 파싱 완료 후 HTML 파싱이 중단된 지점부터 다시 HTML 파싱함

</br>

## 5. 렌더 트리 생성

- DOM과 CSSOM은 렌더링을 위한 `렌더 트리`로 결합됨
- 렌더 트리는 렌더링을 위한 것으로, 브라우저 화면에 렌더링되는 노드만으로 구성
  (즉, meta태그, script 태그나.. display:none 같은 노드들은 렌더트리에 포함되지 않음)

**이후**

- Layout 단계

  - 브라우저의 뷰포트(Viewport) 내에서 각 노드들의 정확한 위치와 크기를 계산
  - %, vh, vw와 같이 상대적인 위치, 크기 속성을 실제 화면에 그려지는 픽셀 단위로 변환함

- Paint 단계
  - layout 계산 값을 이용해 각 노드를 화면상의 실제 픽셀로 변환하고, 레이어 생성
  - 스타일이 복잡할수록 Paint 시간도 늘어남

**레이아웃 계산과 페인팅이 재차 실행되는 경우**

- JS에 의한 노드 추가 또는 삭제
- 브라우저 창 리사이지에 의한 뷰포트 크기 변경
- HTML 요소의 레이아웃 변경을 발생시키는 스타일 변경

레이아웃 계산과 페인팅은 성능에 악영향을 주므로, 가급적 리렌더링이 발생하지 않게 주의해야 함

</br>

## 6. 자바스크립트 파싱과 실행

- DOM은 HTML문서의 구조, 정보와 더불어 DOM API 제공
- DOM API를 이용하여 DOM을 동적으로 조작할 수 있음
- 렌더링 엔진이 HTML문서를 파싱하던 중 script 태그를 만나면, DOM 생성 중단 후 JS파일을 요청함
- JS코드를 파싱하기 위해 렌더링 엔진-> JS엔진으로 제어권이 넘어감
- JS코드 파싱과 실행 후 다시 렌더링 엔진으로 제어권이 넘어감
- HTML 파싱 중단지점부터 다시 파싱 시작, DOM 생성

</br>

## 7. 리플로우와 리페인트

- DOM이나 CSSOM이 변경되는 경우, 다시 렌더 트리 결합하고 레이아웃과 페인트 과정을 거쳐 렌더링해야함
- 리플로우
  - 레이아웃 계산을 다시 하는 것
  - 노드 추가/삭제, 윈도우 리사이징 등 변경이 레이아웃에 영향을 주면 발생
- 리페인트
  - 다시 페인트 하는 것
  - 레이아웃에 영향이 없는 변경의 경우, 리페인트만 일어남

</br>

## 8. 자바스크립트 파싱에 의한 HTML 파싱 중단

**script 태그를 body 요소 가장 아래에 쓰는 이유**

- JS 실행이전에 DOM 생성 완료하여 렌더링 => 로딩 시간 단축
- DOM 완성 이전에 DOM을 조작하면 문제가 발생할 수 있음

</br>

## 9. script 태그의 async/defer 어트리뷰트

- JS 파싱에 의한 DOM 생성 중단 문제를 해결하기 위해 생긴 script 태그 어트리뷰트
- 외부 JS파일을 로딩하는 경우에만 사용 가능
- HTML 파싱과 외부 JS 파일 로드가 비동기적으로 동시에 진행

**async 어트리뷰트**

- HTML 파싱과 JS 파일 로드가 동시에 진행
- JS 파싱/실행은 JS 로드 직후, HTML 파싱을 중단하고 진행
- 여러개의 script 태그에 async 어트리뷰트를 지정하면, 순서 상관 없이 일단 로드 완료된 파일부터 실행되기 때문에.. 순서 보장이 필요하다면 사용하면 안 됨

**defer 어트리뷰트**

- HTML 파싱과 JS 파일 로드가 동시에 진행
- JS 파싱/실행은 HTML 파싱이 완료된 직후 진행

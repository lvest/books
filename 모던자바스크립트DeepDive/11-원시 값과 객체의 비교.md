# 원시 값과 객체의 비교

- 차이
  - 값
    - `원시` - 변경 불가능
    - `객체` - 변경 가능
  - 값을 변수에 할당 시,
    - `원시` - 변수(확보된 메모리 공간)에 실제 값 저장
    - `객체` - 변수에 참조 값 저장
  - 해당 값을 다른 변수에 할당 시,
    - `원시` - 원시 값이 복사되어 전달 (값에 의한 전달)
    - `객체` - 참조 값이 복사되어 전달 (참조에 의한 전달)

</br>

## 1. 원시 값

### 변경 불가능한 값

- 한번 생성된 원시 값은 읽기 전용 값으로, 변경할 수 없음
  (주의, 값을 변경할 수 없다 O, 변수를 변경할 수 없다 X)
- 변수 재할당 시, 변수가 참조하던 메모리 주소가 바뀌는 이유임
  (값이 변경 가능하다면, 새로운 메모리 공간을 확보할 필요가 없이 원시 값 자체를 변경해버리면 됨)
- 원시 값을 할당한 변수는 재할당 외에 변수 값을 변경할 수 있는 방법이 없음

### 문자열과 불변성

- 문자열은 다른 원시타입과 달리, 몇 개의 문자로 이뤄졌냐에 따라 필요한 메모리 공간의 크기가 결정됨
- 유사 배열 객체
  - 배열처럼 인덱스로 프로퍼티 값에 접근 가능, length 프로퍼티 가짐
    (원시값을 객체처럼 사용하면 원시 값을 감싸는 래퍼 객체로 자동 변환)
  - 하지만, 원시값이므로 인덱스로 접근한 문자를 바꿀 수는 없음

### 값에 의한 전달

- 변수에 변수를 할당하면, 할당되는 변수의 원시 값이 복사되어 전달됨
  - 정확히는 메모리 주소가 전달되어 값을 참조하는데 두 가지 경우가 있음
    - 값이 복사된 새로운 메모리 주소를 받는 경우
    - 처음에는 원본과 같은 메모리 주소를 받다가, 재할당 시점에 새로운 메모리를 쓰는 경우 (파이썬)
- 어찌됐건, 한쪽 변수에 재할당 하는 시점에는 두 변수는 별개의 메모리를 가짐
  => 한 쪽을 재할당해도 다른 쪽에 영향을 끼치지 않음

```js
let score = 80;
let copy = score;

score = 100;

console.log(score); // 100
console.log(copy); // 80
```

</br>

## 2. 객체

### 변경 가능한 값

- 변수가 가진 메모리 주소로 가면,
  - `원시타입` - 원시 값이 나옴
  - `객체타입` - 객체가 저장된 메모리 공간의 주소(참조 값)가 나옴, 참조값을 통해 실제 객체에 접근.
- 객체의 크기가 일정하지 않고 매우 클 수도 있기 때문에, 원시 타입처럼 매번 복사하는 것이 비효율적
  => 변경 가능한 값으로 설계
  => 재할당 없이 프로퍼티 동적 추가, 갱신, 삭제 가능

**단점**

- 여러 개의 식별자가 하나의 객체를 공유할 수도 있음

### 참조에 의한 전달

```js
let person = {
  name: "Lee",
};
let copy = score;
```

- `person`은 객체가 있는 메모리의 주소(참조값)을 가지고 있음
  => `person`을 복사한 `copy` 역시 참조값을 가지게 됨 (참조값이 담긴 메모리 공간은 서로 다르긴 하지만)
  => 결국 같은 객체를 공유
  => 즉, 한 쪽에서 객체의 프로퍼티를 추가, 변경, 삭제할 경우, 다른 쪽에도 영향이 감
